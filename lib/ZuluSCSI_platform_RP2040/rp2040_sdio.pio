; RP2040 PIO program for implementing SD card access in SDIO mode
; Run "pioasm rp2040_sdio.pio rp2040_sdio.pio.h" to regenerate the C header from this.

; The RP2040 official work-in-progress code at
; https://github.com/raspberrypi/pico-extras/tree/master/src/rp2_common/pico_sd_card
; may be useful reference, but this is independent implementation.
;
; For official SDIO specifications, refer to:
; https://www.sdcard.org/downloads/pls/
; "SDIO Physical Layer Simplified Specification Version 8.00"

; Clock settings
; For 3.3V communication the available speeds are:
; - Default speed: max. 25 MHz clock
; - High speed:    max. 50 MHz clock
;
; From the default RP2040 clock speed of 125 MHz, the closest dividers
; are 3 for 41.7 MHz and 5 for 25 MHz. The CPU can apply further divider
; through state machine registers for the initial handshake.
;
; Because data is written on the falling edge and read on the rising
; edge, it is preferrable to have a long 0 state and short 1 state.
;.define CLOCK_DIVIDER 3
.define CLOCK_DIVIDER 25
.define D1 (CLOCK_DIVIDER/2 - 1)
.define D0 ((CLOCK_DIVIDER + 1) / 2 - 1)
.define SDIO_CLK_GPIO 18

; State machine 0 is used to:
; - generate continuous clock on SDIO_CLK
; - send CMD packets
; - receive response packets
;
; Pin mapping for this state machine:
; - Sideset    : CLK
; - IN/OUT/SET : CMD
; - JMP_PIN    : CMD
;
; The commands to send are put on TX fifo and must have two words:
; Word 0 bits 31-24: Number of bits in command minus one (usually 47)
; Word 0 bits 23-00: First 24 bits of the command packet, shifted out MSB first
; Word 1 bits 31-08: Last 24 bits of the command packet, shifted out MSB first
; Word 1 bits 07-00: Number of bits in response minus one (usually 47), or 0 if no response
;
; The response is put on RX fifo, starting with the MSB.
; Partial last word will be padded with zero bits at the top.
;
; The state machine EXECCTRL should be set so that STATUS indicates TX FIFO < 2
; and that AUTOPULL and AUTOPUSH are enabled.

.program sdio_cmd_clk
    .side_set 1

    mov OSR, NULL       side 1 [D1]    ; Make sure OSR is full of zeros to prevent autopull

wait_cmd:
    mov Y, !STATUS      side 0 [D0]    ; Check if TX FIFO has data
    jmp !Y wait_cmd     side 1 [D1]

load_cmd:
    out NULL, 32        side 0 [D0]    ; Load first word (trigger autopull)
    out X, 8            side 1 [D1]    ; Number of bits to send
    set pins, 1         side 0 [D0]    ; Initial state of CMD is high
    set pindirs, 1      side 1 [D1]    ; Set SDIO_CMD as output

send_cmd:
    out pins, 1         side 0 [D0]    ; Write output on falling edge of CLK
    jmp X-- send_cmd    side 1 [D1]

prep_resp:
    set pindirs, 0      side 0 [D0]    ; Set SDIO_CMD as input
    out X, 8            side 1 [D1]    ; Get number of bits in response
    nop                 side 0 [D0]    ; For clock alignment
    jmp !X resp_done    side 1 [D1]    ; Check if we expect a response

wait_resp:
    nop                  side 0 [D0]
    jmp PIN wait_resp    side 1 [D1]    ; Loop until SDIO_CMD = 0

    ; Note: input bits are read at the same time as we write CLK=0.
    ; Because the host controls the clock, the read happens before
    ; the card sees the falling clock edge. This gives maximum time
    ; for the data bit to settle.
read_resp:
    in PINS, 1          side 0 [D0]    ; Read input data bit
    jmp X-- read_resp   side 1 [D1]    ; Loop to receive all data bits

resp_done:
    push                side 0 [D0]    ; Push the remaining part of response

; State machine 1 is used to send and receive data blocks.
; Pin mapping for this state machine:
; - IN / OUT: SDIO_D0-D3
; - GPIO defined at beginning of this file: SDIO_CLK

; Data reception program
; This program will wait for initial start of block token and then
; continuously receive data. The application can set limit of bytes
; to receive by using DMA controller, and the final checksum will
; fit in state machine RX FIFO.
.program sdio_data_rx

wait_start:
    wait 0 pin 0                ; Wait for zero state on D0
    wait 1 gpio SDIO_CLK_GPIO   ; Wait for rising edge

.wrap_target
    wait 0 gpio SDIO_CLK_GPIO
    wait 1 gpio SDIO_CLK_GPIO   ; Wait for rising clock edge
    in PINS, 4                  ; Read nibble
.wrap

; Data transmission program
; This program will simply send nibbles out to pins, synchronous
; to the clock signal. The application should prepend 0xF0 to the data
; for the start of block token, and append the checksum.
; The data should be padded to full 32 bits by 0xFF bytes.
.program sdio_data_tx
    wait 1 gpio SDIO_CLK_GPIO
    wait 0 gpio SDIO_CLK_GPIO   ; Wait for falling clock edge
    out PINS, 4                 ; Write nibble
